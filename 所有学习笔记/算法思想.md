### 动态规划

> 常见题型有两种：一个变量的规划、两个变量的规划

##### 1、一个变量的规划

- 常见题型：**求最值**

- 求解三部曲
  1. 分解子问题
  2. 求得每个子问题的最优解
  3. 求取所有子问题最优解中的最值
- 实际操作注意事项
  1. 如何分解子问题：找出题目中给出的 **n（数字、数组长度）**，子问题即1、2、3...n
  2. 如何确定子问题最优解：子问题最优解的来源一般有两个（前面更小的子问题的最优解与当前值相结合、当前值自身所得结果）
  3. 子问题最优解的保存问题：若仅使用相邻子问题的最优解，用一个变量保存即可，若会使用到非相邻子问题的最优解，用数组保存

##### 2、两个变量的规划

- 常见题型：**求变量1和变量2组合生成的结果**
- 求解三部曲
  1. 分解子问题：变量1的前 i 项和变量2的前 j 项组合的结果
  2. 定义二维dp数组，确定状态转移方程，求出 dp[i]\[j]
  3. 最后的 dp[m]\[n] 即为结果（m、n分别为变量1、变量2的长度）
- 实际操作注意事项
  1. 状态转移方程：一般 dp[i]\[j] 由 dp[i-1]\[j] 和 dp[i]\[j-1] 以及某些特定条件得出
  2. dp[i]\[j] 在代码层面的求解步骤有两种
     1. 设置初始值、求解第一行、求解第一列、求解其余行列：需要3个for循环，但每一步都清晰明了
     2. 设置初始值、1个for循环内套2个if求出所有行列：两个if为 i > 0 和 j >0，该方法有点绕
  3. 有时二维dp可以压缩为一维dp：只使用 dp[i-1]\[j] 和 dp[i]\[j-1] 时，也即第 i 行只和第 i-1 行有关时

### 排序算法

##### 1、快速排序

```go
func partition(nums []int) int {
	low, high := 0, len(nums)-1
	index := 0	//选取划分位置，此处为简单赋值，可另写一个函数随机选择位置
	nums[low], nums[index] = nums[index], nums[low]	 //将选中元素放在low处，便于后续操作
	key := nums[low]	
	for low < high {
        for low < high && nums[high] >= key { high-- }   //从高位往低位遍历，找到第一个小于key的下标
		nums[low] = nums[high]                          //将小于key的值放在左边
		for low < high && nums[low] <= key { low++ }    //从低位往高位遍历，找到第一个大于key的下标
		nums[high] = nums[low] 						  //将大于key的值放在右边
	}
	nums[low] = key
	return low
}

func quickSort(nums []int) {
	if len(nums) > 1 {
		index := partition(nums)
		quickSort(nums[:index])
		quickSort(nums[index+1:])	//注意+1
	}
}
```

##### 2、归并排序

###### 非递归版本

```go
func mergeSort(nums []int) {
	n := len(nums)
	temp := make([]int, n)
    //合并两个有序数组，第三个参数 i 表示在 temp 中的起始位置
	merge := func(arr1, arr2 []int, i int) {
		j, k := 0, 0
		for ; j < len(arr1) && k < len(arr2); i++ {
			if arr1[j] < arr2[k] {
				temp[i] = arr1[j]
				j++
			} else {
				temp[i] = arr2[k]
				k++
			}
		}
		for ; j < len(arr1); j, i = j+1, i+1 {
			temp[i] = arr1[j]
		}
		for ; k < len(arr2); k, i = k+1, i+1 {
			temp[i] = arr2[k]
		}
	}
	for i := 1; i < n; i *= 2 {		//步长
		j, k := 0, i				//j, k 分别表示两个数组的起始位置
		for ; k < n; j, k = k+i, k+i+i {	
			if k+i < n {
				merge(nums[j:k], nums[k:k+i], j)
			} else {
				merge(nums[j:k], nums[k:n], j)
			}
		}
		for i := 0; i < j && i < n; i++ {	// i < j 是为了：当分割成的数组为奇数个时，最后剩余一个数组不参与合并，保持不动
			nums[i] = temp[i]
		}
		fmt.Println(nums)
	}
}
```

###### 递归版本

```go
func merge(arr1, arr2 []int) {
    //申请辅助数组
	temp := make([]int, len(arr1)+len(arr2))
    //将元素排序写入辅助数组中
	i, j, k := 0, 0, 0
	for ; j < len(arr1) && k < len(arr2); i++ {
		if arr1[j] < arr2[k] {
			temp[i] = arr1[j]
			j++
		} else {
			temp[i] = arr2[k]
			k++
		}
	}
	for ; j < len(arr1); j, i = j+1, i+1 {
		temp[i] = arr1[j]
	}
	for ; k < len(arr2); k, i = k+1, i+1 {
		temp[i] = arr2[k]
	}
    //将结果写回原数组
	i, j, k = 0, 0, 0
	for ; j < len(arr1); i, j = i+1, j+1 {
		arr1[j] = temp[i]
	}
	for ; k < len(arr2); i, k = i+1, k+1 {
		arr2[k] = temp[i]
	}
}
func mergeSort2(nums []int) {
	mid := len(nums) / 2
	if mid >= 1 {
		mergeSort2(nums[:mid])
		mergeSort2(nums[mid:])
		merge(nums[:mid], nums[mid:])
	}
}
```

